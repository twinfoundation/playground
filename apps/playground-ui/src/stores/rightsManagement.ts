// Copyright 2024 IOTA Stiftung.
// SPDX-License-Identifier: Apache-2.0.
import { ErrorHelper, Is } from "@twin.org/core";
import type { EntityCondition } from "@twin.org/entity";
import { RightsManagementClient } from "@twin.org/rights-management-rest-client";
import type { IOdrlPolicy } from "@twin.org/standards-w3c-odrl";

let rightsManagementClient: RightsManagementClient | undefined;

/**
 * Initialise the rights management client.
 * @param apiUrl The API url.
 */
export async function init(apiUrl: string): Promise<void> {
	rightsManagementClient = new RightsManagementClient({
		endpoint: apiUrl
	});
}

/**
 * Get a policy.
 * @param proofId The id of the policy.
 * @returns The policy or an error if one occurred.
 */
export async function policyGet(proofId: string): Promise<
	| {
			error?: string;
			item?: IOdrlPolicy;
	  }
	| undefined
> {
	if (Is.object(rightsManagementClient)) {
		try {
			const result = await rightsManagementClient.papRetrieve(proofId);
			return {
				item: result
			};
		} catch (err) {
			return {
				error: ErrorHelper.formatErrors(err).join("\n")
			};
		}
	}
}

/**
 * Create a new policy.
 * @param policyObject The policy object to create, it comes without the uid since that will be generated by the server.
 * @returns The id of the created policy or an error if one occurred.
 */
export async function policyCreate(policyObject: IOdrlPolicy): Promise<
	| {
			error?: string;
			uid?: string;
	  }
	| undefined
> {
	if (Is.object(rightsManagementClient)) {
		try {
			const result = await rightsManagementClient.papCreate(policyObject);

			return { uid: result };
		} catch (err) {
			return {
				error: ErrorHelper.formatErrors(err).join("\n")
			};
		}
	}
}

/**
 * Update a policy.
 * @param policyObject The policy object to create.
 * @returns The id of the created policy or an error if one occurred.
 */
export async function policyUpdate(policyObject: IOdrlPolicy): Promise<
	| {
			error?: string;
	  }
	| undefined
> {
	if (Is.object(rightsManagementClient)) {
		try {
			await rightsManagementClient.papUpdate(policyObject);
			return undefined;
		} catch (err) {
			return {
				error: ErrorHelper.formatErrors(err).join("\n")
			};
		}
	}
}

/**
 * Remove a Policy.
 * @param policyId The id of the policy to remove.
 * @returns Nothing or an error if one occurred.
 */
export async function policyRemove(policyId: string): Promise<undefined | { error: string }> {
	if (Is.object(rightsManagementClient)) {
		try {
			await rightsManagementClient.papRemove(policyId);
			return undefined;
		} catch (err) {
			return {
				error: ErrorHelper.formatErrors(err).join("\n")
			};
		}
	}
}

/**
 * Query policies with optional conditions and pagination.
 * @param conditions The conditions for filtering policies.
 * @param cursor The cursor for pagination.
 * @param pageSize The page size for pagination.
 * @returns Nothing or an error if one occurred.
 */
export async function policyQuery(
	conditions?: EntityCondition<IOdrlPolicy>,
	cursor?: string,
	pageSize?: number
): Promise<undefined | { error?: string; cursor?: string; policies?: IOdrlPolicy[] }> {
	if (Is.object(rightsManagementClient)) {
		try {
			const result = await rightsManagementClient.papQuery(conditions, cursor, pageSize);
			return {
				cursor: result.cursor,
				policies: result.policies
			};
		} catch (err) {
			return {
				error: ErrorHelper.formatErrors(err).join("\n")
			};
		}
	}
}
