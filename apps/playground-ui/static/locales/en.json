{
	"error": {
		"validation": {
			"beEmpty": "{fieldName} must be empty",
			"beNotEmpty": "{fieldName} must not be empty",
			"beText": "{fieldName} must be text",
			"beTextValue": "{fieldName} must contain some text",
			"beTextMinMax": "{fieldName} must be longer than {minLength} and shorter than {maxLength} characters",
			"beTextMin": "{fieldName} must be longer than {minLength} characters",
			"beTextMax": "{fieldName} must be shorter than {maxLength} characters",
			"beTextBase58": "{fieldName} must be text formatted using Base58 characters",
			"beTextBase64": "{fieldName} must be text formatted using Base64 characters",
			"beTextHex": "{fieldName} must be text formatted using Hex characters",
			"beTextRegExp": "{fieldName} must be text formatted using the matching pattern {format}",
			"beNumber": "{fieldName} must be a number",
			"beNumberMinMax": "{fieldName} must be >= {minValue} and <= {maxValue}",
			"beNumberMin": "{fieldName} must be >= {minValue}",
			"beNumberMax": "{fieldName} must be <= {maxValue}",
			"beWholeNumber": "{fieldName} must be a whole number",
			"beWholeNumberMinMax": "{fieldName} must be a whole number >= {minValue} and <= {maxValue}",
			"beWholeNumberMin": "{fieldName} must be a whole number >= {minValue}",
			"beWholeNumberMax": "{fieldName} must be a whole number <= {maxValue}",
			"beBigInteger": "{fieldName} must be a bigint",
			"beBigIntegerMinMax": "{fieldName} must be a bigint >= {minValue} and <= {maxValue}",
			"beBigIntegerMin": "{fieldName} must be a bigint >= {minValue}",
			"beBigIntegerMax": "{fieldName} must be a bigint <= {maxValue}",
			"beBoolean": "{fieldName} must be true or false",
			"beDate": "{fieldName} must be a date",
			"beDateTime": "{fieldName} must be a date/time",
			"beTime": "{fieldName} must be a time",
			"beTimestampMilliseconds": "{fieldName} must be a timestamp in milliseconds",
			"beTimestampSeconds": "{fieldName} must be a timestamp in seconds",
			"beObject": "{fieldName} must be an object",
			"beArray": "{fieldName} must be an array",
			"beArrayValue": "{fieldName} must be an array with at least one item",
			"beIncluded": "{fieldName} is unrecognised",
			"beByteArray": "{fieldName} must be a byte array",
			"beUrn": "{fieldName} must be a correctly formatted urn",
			"beUrl": "{fieldName} must be a correctly formatted url",
			"beJSON": "{fieldName} must be correctly formatted JSON",
			"beEmail": "{fieldName} must be a correctly formatted e-mail address",
			"failed": "Validation failed",
			"failedObject": "Validation of \"{objectName}\" failed",
			"properties": {
				"keyAlreadyExists": "The key already exists"
			},
			"schema": {
				"failedValidation": "The JSON schema failed validation, {message}",
				"missingType": "Failed to validate as there is no handler for type \"{dataType}\""
			},
			"geo": {
				"coordinatesNotObject": "The geo coordinates must be an object",
				"coordinatesLatitudeNumber": "The latitude value must be a number",
				"coordinatesLatitudeRange": "The latitude value must be between -90 and 90",
				"coordinatesLongitudeNumber": "The longitude value must be a number",
				"coordinatesLongitudeRange": "The longitude value must be between -180 and 180"
			},
			"auditableItemGraphService": {
				"edgeIdSameAsVertexId": "The edge id \"{id}\"can not point to the vertex it belongs to"
			}
		},
		"guard": {
			"undefined": "Property \"{property}\" must be defined, it is \"{value}\"",
			"string": "Property \"{property}\" must be a string, it is \"{value}\"",
			"stringEmpty": "Property \"{property}\" must have a value, it is empty",
			"stringBase64": "Property \"{property}\" must be a base64 encoded string, it is \"{value}\"",
			"stringBase64Url": "Property \"{property}\" must be a base64 url encoded string, it is \"{value}\"",
			"stringBase58": "Property \"{property}\" must be a base58 encoded string, it is \"{value}\"",
			"stringHex": "Property \"{property}\" must be a hex string, it is \"{value}\"",
			"stringHexLength": "Property \"{property}\" must be a hex string of length \"{options}\", it is \"{value}\"",
			"stringJson": "Property \"{property}\" must be a JSON string",
			"number": "Property \"{property}\" must be a number, it is \"{value}\"",
			"integer": "Property \"{property}\" must be an integer, it is \"{value}\"",
			"bigint": "Property \"{property}\" must be a bigint, it is \"{value}\"",
			"boolean": "Property \"{property}\" must be a boolean, it is \"{value}\"",
			"date": "Property \"{property}\" must be a date, it is \"{value}\"",
			"timestampMilliseconds": "Property \"{property}\" must be a timestamp in milliseconds, it is \"{value}\"",
			"timestampSeconds": "Property \"{property}\" must be a timestamp in seconds, it is \"{value}\"",
			"objectUndefined": "Property \"{property}\" must be an object, it is \"undefined\"",
			"object": "Property \"{property}\" must be an object, it is \"{value}\"",
			"objectValue": "Property \"{property}\" must be an object, with at least one property, it is \"{value}\"",
			"array": "Property \"{property}\" must be an array, it is \"{value}\"",
			"arrayValue": "Property \"{property}\" must be an array with at least one item",
			"arrayOneOf": "Property \"{property}\" must be one of [{options}], it is \"{value}\"",
			"arrayStartsWith": "Property \"{property}\" must be an array starting with [{startValues}], it is \"{value}\"",
			"arrayEndsWith": "Property \"{property}\" must be an array ending with [{endValues}], it is \"{value}\"",
			"uint8Array": "Property \"{property}\" must be a Uint8Array, it is \"{value}\"",
			"function": "Property \"{property}\" must be a function, it is \"{value}\"",
			"urn": "Property \"{property}\" must be a Urn formatted string, it is \"{value}\"",
			"url": "Property \"{property}\" must be a Url formatted string, it is \"{value}\"",
			"email": "Property \"{property}\" must be string in e-mail format, it is \"{value}\"",
			"length32Multiple": "Property \"{property}\" should be a multiple of 32, it is {value}",
			"lengthEntropy": "Property \"{property}\" should be a multiple of 4, >=16 and <= 32, it is {value}",
			"length3Multiple": "Property \"{property}\" should be a multiple of 3, it is {value}",
			"greaterThan0": "Property \"{property}\" must be greater than zero, it is {value}"
		},
		"objectHelper": {
			"failedBytesToJSON": "Failed converting bytes to JSON",
			"cannotSetArrayIndex": "Cannot set property \"{property}\" using index \"{index}\" as it is not an array",
			"cannotSetProperty": "Cannot set property \"{property}\" when the target is not an object"
		},
		"common": {
			"notImplementedMethod": "The method \"{method}\" has not been implemented",
			"validation": "Validation failed"
		},
		"factory": {
			"noUnregister": "There is no {typeName} registered with the name \"{name}\"",
			"noGet": "The requested {typeName} \"{name}\" does not exist in the factory"
		},
		"bitString": {
			"outOfRange": "The index should be >= 0 and less than the length of the bit string"
		},
		"base32": {
			"invalidCharacter": "Data contains a character \"{invalidCharacter}\" which is not in the charset"
		},
		"base64": {
			"length4Multiple": "Invalid length should be a multiple of 4, it is \"{value}\""
		},
		"base58": {
			"invalidCharacter": "Data contains a character \"{invalidCharacter}\" which is not in the charset"
		},
		"jsonHelper": {
			"failedPatch": "Failed to patch the JSON object, patch index \"{index}\" failed"
		},
		"fetchHelper": {
			"decodingJSON": "Decoding JSON failed for route \"{route}\"",
			"failureStatusText": "The request to the API failed: \"{statusText}\"",
			"connectivity": "The request failed, the API could be offline, or there are other connectivity issues",
			"timeout": "The request timed out",
			"general": "A general failure occurred during the request"
		},
		"jwt": {
			"noKeyOrSigner": "No key or signer was provided for JWT creation",
			"noKeyOrVerifier": "No key or verifier was provided for JWT creation",
			"verifyFailed": "Failed to verify JWT",
			"invalidTokenParts": "The JSON Web Token could not be parsed, it should contain three parts separated by dots",
			"invalidSigningBytes": "The signing bytes are invalid, it should contain two parts separated by a dot"
		},
		"jwk": {
			"jwkImportFailed": "Failed to import JWK"
		},
		"jws": {
			"createFailed": "Failed to create JWS",
			"verifyFailed": "Failed to verify JWS"
		},
		"bip39": {
			"missingMnemonicWord": "The mnemonic contains a word not in the wordlist, \"{value}\"",
			"checksumMismatch": "The checksum does not match \"{newChecksum}\" != \"{checksumBits}\""
		},
		"ed25519": {
			"privateKeyLength": "The private key length is incorrect, it should be \"{requiredSize}\" but is \"{actualSize}\"",
			"publicKeyLength": "The public key length is incorrect, it should be \"{requiredSize}\" but is \"{actualSize}\""
		},
		"secp256k1": {
			"privateKeyLength": "The private key length is incorrect, it should be \"{requiredSize}\" but is \"{actualSize}\"",
			"publicKeyLength": "The public key length is incorrect, it should be \"{requiredSize}\" but is \"{actualSize}\""
		},
		"x25519": {
			"invalidPublicKey": "Invalid Ed25519 Public Key"
		},
		"blake2b": {
			"outputLength64": "The output length should be between 1 and 64, it is \"{outputLength}\"",
			"keyLength64": "The key length should be between 1 and 64, it is \"{keyLength}\""
		},
		"sha512": {
			"bitSize": "Only 224, 256, 384 or 512 bits are supported, it is \"{bitSize}\""
		},
		"sha256": {
			"bitSize": "Only 224 or 256 bits are supported, it is \"{bitSize}\""
		},
		"sha3": {
			"bitSize": "Only 224, 256, 384 or 512 bits are supported, it is \"{bitSize}\""
		},
		"hmacSha256": {
			"bitSize": "Only 224 or 256 bits are supported, it is \"{bitSize}\""
		},
		"hmacSha512": {
			"bitSize": "Only 224, 256, 384 or 512 bits are supported, it is \"{bitSize}\""
		},
		"bech32": {
			"decodeFailed": "The address contains decoding failed for address \"{bech32}\"",
			"invalidChecksum": "The address contains an invalid checksum in address, \"{bech32}\"",
			"separatorMisused": "The separator character '1' should only be used between hrp and data, \"{bech32}\"",
			"lowerUpper": "The address my use either lowercase or uppercase, \"{bech32}\"",
			"dataTooShort": "The address does not contain enough data to decode, \"{bech32}\""
		},
		"pbkdf2": {
			"keyTooLong": "The requested key length \"{keyLength}\" is too long, based on the \"{macLength}\""
		},
		"chaCha20Poly1305": {
			"noAadWithData": "You can not set the aad when there is already data",
			"noAuthTag": "Can not finalise when the auth tag is not set",
			"authenticationFailed": "The data could not be authenticated",
			"authTagDecrypting": "Can not get the auth tag when decrypting",
			"authTagEncrypting": "Can not set the auth tag when encrypting",
			"noAuthTagSet": "The auth tag has not been set"
		},
		"bip44": {
			"unsupportedKeyType": "The key type \"{keyType}\" is not supported"
		},
		"slip0010": {
			"invalidSeed": "The seed is invalid \"{seed}\""
		},
		"baseRestClient": {
			"missingRouteProp": "Missing route parameter in data \"{routeProp}\" for route \"{route}\"",
			"decodingFailed": "Decoding JSON failed for route \"{route}\"",
			"failureStatusText": "The request to the API failed: \"{statusText}\""
		},
		"entitySchemaHelper": {
			"noIsPrimary": "Property \"entitySchema.properties\" must contain a value with isPrimary set",
			"multipleIsPrimary": "Property \"entitySchema.properties\" contains more than one property with isPrimary set",
			"invalidEntityProperties": "The schema has no properties defined, but the entity has properties",
			"invalidEntityProperty": "The entity value of \"{value}\" does not match the type \"{type}\" for property \"{property}\"",
			"invalidOptional": "The entity property \"{property}\" of type \"{type}\" is not optional, but no value has been provided",
			"invalidEntityKeys": "The entity had additional properties that are not in the schema, \"{keys}\""
		},
		"jsonLdProcessor": {
			"compact": "The JSON-LD compaction failed",
			"expand": "The JSON-LD expansion failed",
			"canonize": "The JSON-LD canonization failed",
			"invalidUrl": "The JSON-LD processing failed to retrieve from the following url \"{url}\"",
			"jsonLdError": "The JSON-LD processing failed due to the following error: \"{code}\""
		},
		"proofHelper": {
			"unsupportedProofType": "Proof type \"{proofType}\" not supported.",
			"proofMissing": "Proof is missing."
		},
		"jsonWebSignature2020SignerVerifier": {
			"missingPrivateKey": "Private key is missing.",
			"missingPublicKey": "Public key is missing.",
			"missingProofValue": "Proof value is missing."
		},
		"dataIntegrityProofSignerVerifier": {
			"cryptosuiteNotSupported": "Cryptosuite \"{cryptosuite}\" is not supported.",
			"missingPrivateKey": "Private key is missing.",
			"missingPublicKey": "Public key is missing.",
			"missingProofValue": "Proof value is missing."
		},
		"multikeyHelper": {
			"invalidPublicKeyMultibase": "Public key multibase \"{publicKeyMultibase}\" is invalid.",
			"invalidSecretKeyMultibase": "Secret key multibase \"{secretKeyMultibase}\" is invalid.",
			"unsupportedCrv": "Curve \"{crv}\" is not supported.",
			"unsupportedKty": "Key type \"{kty}\" is not supported.",
			"publicKeyMultibaseMissingHeader": "Public key multibase \"{publicKeyMultibase}\" is missing the multi codec header",
			"secretKeyMultibaseMissingHeader": "Secret key multibase \"{secretKeyMultibase}\" is missing the multi codec header"
		},
		"verificationHelper": {
			"jwtDecodeFailed": "Decoding the JWT failed",
			"proofTypeNotSupported": "The proof type \"{proofType}\" is not supported",
			"proofMissingVerificationMethod": "The proof is missing the verification method"
		},
		"documentHelper": {
			"verificationMethodNotFound": "The verification method \"{methodName}\" of type \"{methodType}\" could not be found",
			"verificationMethodJwkNotFound": "The verification method \"{methodName}\" of type \"{methodType}\" is missing the JWK"
		},
		"qr": {
			"typeNumberRange": "The typeNumber parameter should be a number >= 0 and <= 40, it is {typeNumber}",
			"dataOverflow": "There is not enough space in the QR code to store the data, {lengthInBits} > {totalDataCount}, try increasing the typeNumber from {typeNumber}, or use 0 for auto detect",
			"typeNumberOverflow": "There is not enough space in the QR code to store the data, {lengthInBits} > {totalDataCount}, typeNumber cannot be greater than 40"
		},
		"rendererOptions": {
			"cellSizeZero": "The cellSize must be a number > 0, it is \"{cellSize}\"",
			"marginSizeZero": "The marginSize must be a number >= 0, it is \"{marginSize}\""
		},
		"qRAlphaNumeric": {
			"illegalCharacter ": "Illegal character in string \"{value}\""
		},
		"qRNumber": {
			"illegalCharacter ": "Illegal character in string \"{value}\""
		},
		"mathHelper": {
			"lessThanOne ": "The value can not be less than 1, it is \"{value}\""
		},
		"qrHelper": {
			"correctionLevelRange ": "The errorCorrectLevel parameter should be one of the following: \"L\", \"M\", \"Q\", \"H\", it is \"{errorCorrectLevel}\"",
			"modeRange ": "The mode parameter should be one of the following: \"Byte\", \"Numeric\", \"Alphanumeric\", it is \"{mode}\"",
			"maskPatternRange ": "The maskPattern parameter should be a number >= 0 and <= 7, it is \"{maskPattern}\""
		},
		"rSBlock": {
			"correctionLevelRange ": "The errorCorrectLevel parameter should be one of the following: \"L\", \"M\", \"Q\", \"H\", it is \"{errorCorrectLevel}\""
		},
		"qRDataBase": {
			"invalidMode": "Invalid mode {mode} for typeNumber {typeNumber}",
			"invalidTypeNumber": "Invalid typeNumber {typeNumber}, it should be less than <= 40"
		},
		"jpegEncoder": {
			"invalidQuality": "Quality must be between 1 and 100, it is \"{value}\""
		},
		"nftAttestationConnector": {
			"attestingFailed": "Attesting the data failed",
			"verificationFailed": "Verifying the attestation failed",
			"transferFailed": "Transferring the attestation failed",
			"destroyFailed": "Destroying the attestation failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the NFT Attestation connector \"{namespace}\""
		},
		"attestationService": {
			"noConnectors": "There are no connectors registered with the attestation factory",
			"attestFailed": "The attestation of the data failed",
			"verifyFailed": "The verification of the attestation failed",
			"transferFailed": "The transfer of the attestation failed",
			"destroyFailed": "The destruction of the attestation failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the attestation service \"{namespace}\""
		},
		"entityStorageAuthenticationService": {
			"loginFailed": "Login failed",
			"refreshFailed": "Refresh failed",
			"userNotFound": "The user with the specified e-mail could not be found",
			"passwordMismatch": "The password does not match the user's password"
		},
		"entityStorageAuthenticationProcessor": {
			"initializeFailed": "The JSON Web token authentication processor could not be initialized"
		},
		"tokenHelper": {
			"missing": "The JSON Web token could not be found in the authorization header",
			"payloadMissingSubject": "The JSON Web token payload does not contain a subject",
			"expired": "The JSON Web token has expired"
		},
		"restRouteProcessor": {
			"routeNotFound": "The web server could not find the REST route \"{notFoundId}\""
		},
		"socketRouteProcessor": {
			"routeNotFound": "The web server could not find the socket route \"{notFoundId}\""
		},
		"jwtIdentityProcessor": {
			"jwtMissing": "The JSON Web token could not be found in the authorization header or a cookie",
			"jwtSignatureInvalid": "The JSON Web token signature could not be validated",
			"jwtExpired": "The JSON Web token has expired"
		},
		"auditableItemGraphService": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the Auditable Item Graph service \"{namespace}\"",
			"createFailed": "Creating the Auditable Item Graph vertex failed",
			"getFailed": "Getting the Auditable Item Graph vertex failed",
			"updatingFailed": "Updating the Auditable Item Graph vertex failed",
			"queryingFailed": "Querying the Auditable Item Graph failed",
			"removeVerifiableFailed": "Removing the verifiable data the Auditable Item Graph vertex failed",
			"vertexNotFound": "The vertex with the Id \"{notFoundId}\" was not found",
			"resourceIdMissing": "You must provide either the id, or the resourceObject must contain an id property for index \"{index}\""
		},
		"auditableItemStreamService": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the Auditable Item Stream service \"{namespace}\"",
			"createFailed": "Creating the Auditable Item Stream failed",
			"getFailed": "Getting the Auditable Item Stream failed",
			"updatingFailed": "Updating the Auditable Item Stream failed",
			"removingFailed": "Removing Auditable Item Stream failed",
			"queryingFailed": "Querying the Auditable Item Stream failed",
			"creatingEntryFailed": "Creating entry in the Auditable Item Stream failed",
			"updatingEntryFailed": "Updating entry in the Auditable Item Stream failed",
			"gettingEntryFailed": "Getting entry from the Auditable Item Stream failed",
			"gettingEntryObjectFailed": "Getting entry object from the Auditable Item Stream failed",
			"removingEntryFailed": "Removing entry from the Auditable Item Stream failed",
			"gettingEntriesFailed": "Getting entries from the Auditable Item Stream failed",
			"gettingEntryObjectsFailed": "Getting entry objects from the Auditable Item Stream failed",
			"removeImmutableFailed": "Removing immutable entry from the Auditable Item Stream failed",
			"streamNotFound": "The stream with the Id \"{notFoundId}\" was not found",
			"streamEntryNotFound": "The stream entry with the Id \"{notFoundId}\" was not found",
			"streamMismatch": "The stream Id in the entry Id \"{streamEntryNamespaceId}\" does not match the stream Id \"{streamNamespaceId}\""
		},
		"s3BlobStorageConnector": {
			"bucketCreateFailed": "Creating bucket \"{bucket}\" failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\"",
			"getBlobFailed": "Failed to get blob in S3",
			"setBlobFailed": "Failed to set blob in S3",
			"removeBlobFailed": "Failed to remove blob in S3"
		},
		"azureBlobStorageConnector": {
			"containerCreateFailed": "Creating container \"{container}\" failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\"",
			"getBlobFailed": "Failed to get blob in Azure",
			"setBlobFailed": "Failed to set blob in Azure",
			"removeBlobFailed": "Failed to remove blob in Azure"
		},
		"gcpBlobStorageConnector": {
			"bucketCreateFailed": "Creating bucket \"{bucket}\" failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\"",
			"getBlobFailed": "Failed to get blob in GCP",
			"setBlobFailed": "Failed to set blob in GCP",
			"removeBlobFailed": "Failed to remove blob in GCP"
		},
		"ipfsBlobStorageConnector": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\"",
			"fetchFail": "Failure during IPFS request",
			"setBlobFailed": "Failed to store blob in IPFS",
			"getBlobFailed": "Failed to get blob from IPFS",
			"removeBlobFailed": "Failed to remove blob from IPFS"
		},
		"fileBlobStorageConnector": {
			"directoryCreateFailed": "Creating directory \"{directory}\" failed",
			"getBlobFailed": "Unable to get blob \"{id}\"",
			"setBlobFailed": "Unable to set blob",
			"removeBlobFailed": "Unable to remove blob",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\""
		},
		"memoryBlobStorageConnector": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage \"{namespace}\""
		},
		"blobStorageService": {
			"noConnectors": "There are no connectors registered with the blob storage factory",
			"createFailed": "There was a problem storing the blob",
			"getFailed": "There was a problem getting the blob",
			"updateFailed": "There was a problem updating the blob",
			"removeFailed": "There was a problem removing the blob",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the blob storage service \"{namespace}\"",
			"vaultConnectorNotConfigured": "The vault connector is not configured, but encryption/decryption was requested."
		},
		"commands": {
			"common": {
				"missingEnv": "The \"{option}\" option is configured as an environment variable, but there is no environment variable with the name \"{value}\" set.",
				"optionInvalidHex": "The \"{option}\" does not appear to be hex. \"{value}\"",
				"optionInvalidBase64": "The \"{option}\" does not appear to be base64. \"{value}\"",
				"optionInvalidHexBase64": "The \"{option}\" does not appear to be hex or base64. \"{value}\"",
				"optionInvalidBech32": "The \"{option}\" does not appear to be bech32. \"{value}\"",
				"optionMinValue": "The \"{option}\" option must be greater than or equal to {minValue}, it is {value}.",
				"optionMaxValue": "The \"{option}\" option must be less than or equal to {maxValue}, it is {value}."
			}
		},
		"dataProcessingService": {
			"noExtractorFound": "No extractors could be found in the factory",
			"ruleGroupNotFound": "The rule group with id \"{notFoundId}\" could not be found",
			"mimeTypeNotFound": "Unable to detect MIME type from data",
			"converterNotFound": "Unable to find a converter for the MIME type \"{notFoundId}\""
		},
		"dynamoDbEntityStorageConnector": {
			"tableCreateFailed": "Creating table \"{tableName}\" failed",
			"tableDoesNotExist": "Table \"{tableName}\" does not exist",
			"setFailed": "Unable to set entity \"{id}\"",
			"getFailed": "Unable to get entity \"{id}\"",
			"removeFailed": "Unable to remove entity \"{id}\"",
			"queryFailed": "The query failed",
			"comparisonNotSupported": "Comparison operator \"{comparison}\" is not supported",
			"conditionalNotSupported": "Conditional operator \"{operator}\" is not supported",
			"sortSingle": "You can only sort by a single property",
			"sortNotIndexed": "The property \"{property}\" is not indexed and cannot be used for sorting"
		},
		"fileEntityStorageConnector": {
			"directoryCreateFailed": "Creating directory \"{directory}\" failed"
		},
		"scyllaDBTableConnector": {
			"tableCreateFailed": "Creating table \"{table}\" failed",
			"getFailed": "Getting item with \"{id}\" failed",
			"dropTableFailed": " \"{table}\" cannot be dropped",
			"truncateTableFailed": " \"{table}\" cannot be dropped",
			"removeFailed": "Removing item with \"{id}\" failed",
			"findFailed": "Error while querying data on  \"{table}\""
		},
		"entityStorageService": {
			"entityNotFound": "Could not find entity with id \"{id}\""
		},
		"entityStorageIdentityResolverConnector": {
			"documentNotFound": "The document could not be found",
			"resolveDocumentFailed": "Resolving the document failed"
		},
		"entityStorageIdentityConnector": {
			"createDocumentFailed": "Creating the document failed",
			"signatureVerificationFailed": "The document integrity check failed",
			"missingDid": "The full id including DID is required",
			"addVerificationMethodFailed": "Adding the verification method failed",
			"removeVerificationMethodFailed": "Removing the verification method failed",
			"addServiceFailed": "Adding the service failed",
			"removeServiceFailed": "Removing the service failed",
			"documentNotFound": "The document could not be found",
			"documentPrivateKeyNotFound": "The private key for document could not be found in the vault",
			"verificationMethodNotFound": "The verification method could not be found",
			"verificationPrivateKeyNotFound": "The private key for the verification method could not be found in the vault",
			"serviceNotFound": "The service could not be found",
			"publicKeyJwkMissing": "The verification method contains no publicKeyJwk in method \"{method}\"",
			"jwkSignatureFailed": "The signature on the JWK failed verification",
			"createVerifiableCredentialFailed": "Creating the verifiable credential failed",
			"checkingVerifiableCredentialFailed": "Checking the verifiable credential failed",
			"createVerifiablePresentationFailed": "Creating the verifiable presentation failed",
			"checkingVerifiablePresentationFailed": "Checking the verifiable presentation failed",
			"expectingJwtCredential": "Expecting JWT credential in the presentation",
			"keyIndexOutOfRange": "The supplied keyIndex is not in the range of the key list",
			"createProofFailed": "Creating the signature for the data failed",
			"methodMissing": "The verification method specified does not exist \"{method}\"",
			"verifyProofFailed": "Verifying the signature for the data failed",
			"revokeVerifiableCredentialsFailed": "Revoking verifiable credentials failed",
			"unrevokeVerifiableCredentialsFailed": "Unrevoking verifiable credentials failed",
			"proofType": "The proof type must be DataIntegrityProof, it is currently {proofType}",
			"cryptosuite": "The proof cryptosuite must be eddsa-jcs-2022, it is currently {cryptosuite}"
		},
		"entityStorageIdentityProfileConnector": {
			"alreadyExists": "The identity profile already exists for the identity \"{existingId}\"",
			"createFailed": "Creating the identity profile failed \"{identity}\"",
			"getFailed": "Getting the identity profile failed \"{notFoundId}\"",
			"updateFailed": "Updating the identity profile failed \"{identity}\"",
			"notFound": "The identity profile failed \"{notFoundId}\"",
			"removeFailed": "Removing the identity profile failed \"{identity}\"",
			"listFailed": "Failed listing identities"
		},
		"iotaIdentityResolverConnector": {
			"documentNotFound": "The document could not be found",
			"resolveDocumentFailed": "Resolving the document failed \"{documentId}\""
		},
		"iotaIdentityConnector": {
			"createDocumentFailed": "Creating the document failed",
			"missingDid": "The full id including DID is required",
			"addVerificationMethodFailed": "Adding the verification method failed",
			"removeVerificationMethodFailed": "Removing the verification method failed",
			"addServiceFailed": "Adding the service failed",
			"removeServiceFailed": "Removing the service failed",
			"documentNotFound": "The document could not be found",
			"verificationMethodNotFound": "The verification method could not be found",
			"serviceNotFound": "The service could not be found",
			"publicKeyJwkMissing": "The verification method contains no publicKeyJwk in JWK \"{jwk}\"",
			"publicKeyJwkMethodMissing": "The verification method contains no publicKeyJwk in method \"{method}\"",
			"privateKeyMissing": "The verification method contains no privateKey \"{keyId}\"",
			"verificationKeyMissing": "The verification key is missing from the vault for method \"{method}\"",
			"createVerifiableCredentialFailed": "Creating the verifiable credential failed",
			"checkingVerifiableCredentialFailed": "Checking the verifiable credential failed",
			"createVerifiablePresentationFailed": "Creating the verifiable presentation failed",
			"checkingVerifiablePresentationFailed": "Checking the verifiable presentation failed",
			"createProofFailed": "Creating the signature for the data failed",
			"methodMissing": "The verification method specified does not exist \"{method}\"",
			"verifyProofFailed": "Verifying the signature for the data failed",
			"revokeVerifiableCredentialsFailed": "Revoking verifiable credentials failed",
			"unrevokeVerifiableCredentialsFailed": "Unrevoking verifiable credentials failed",
			"proofType": "The proof type must be DataIntegrityProof, it is currently {proofType}",
			"integerNegative": "The value must be a positive integer, it is currently {value}",
			"invalidDocumentIdFormat": "The document ID format is invalid, it is currently {documentId}",
			"invalidSubjectId": "The subject id format is invalid it must be a Url or Urn, it is \"{subjectId}\"",
			"missingControllerToken": "The controller token is missing",
			"unexpectedExecutionResult": "Could not extract DID from transaction result",
			"objectIdNotFound": "The object ID was not found in the created object",
			"gasStationError": "Gas station transaction execution failed",
			"gasStationTransactionBuildFailed": "Gas station transaction build failed",
			"gasStationTransactionFailed": "Gas station transaction failed",
			"gasStationDocumentUpdateFailed": "Gas station document update failed",
			"didExtractionFailed": "Failed to extract DID from transaction execution result",
			"transactionConfirmationTimeout": "Transaction confirmation timed out",
			"transactionBuildFailed": "Transaction build failed - unexpected build result format",
			"didResolutionFailed": "DID resolution failed",
			"didResolutionFailedAllRetries": "DID resolution failed after all retries",
			"invalidMaxRetries": "The maximum number of retries must be a positive integer, it is currently {maxRetries}",
			"invalidBaseDelay": "The base delay must be a positive integer, it is currently {baseDelay}"
		},
		"identityService": {
			"noConnectors": "There are no connectors registered with the identity factory",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the identity service \"{namespace}\"",
			"connectorNotFound": "There is no connector with the namespace \"{namespace}\" registered with the identity factory",
			"jwtDecodeFailed": "Decoding the JWT failed",
			"identityCreateFailed": "Creating the identity failed",
			"verificationMethodCreateFailed": "Creating the verification method failed for identity \"{identity}\"",
			"verificationMethodRemoveFailed": "Removing the verification method failed \"{verificationMethodId}\"",
			"serviceCreateFailed": "Creating the service failed for identity \"{identity}\", service \"{serviceId}\"",
			"serviceRemoveFailed": "Removing the service failed \"{serviceId}\"",
			"verifiableCredentialCreateFailed": "Creating the verifiable credential failed for method \"{verificationMethodId}\"",
			"verifiableCredentialVerifyFailed": "Verifying the verifiable credential failed",
			"verifiableCredentialRevokeFailed": "Revoking the verifiable credential failed for document \"{issuerIdentity}\" with index \"{credentialIndex}\"",
			"verifiableCredentialUnrevokeFailed": "Unrevoking the verifiable credential failed for document \"{issuerIdentity}\" with index \"{credentialIndex}\"",
			"verifiablePresentationCreateFailed": "Creating the verifiable presentation failed for method \"{verificationMethodId}\"",
			"verifiablePresentationVerifyFailed": "Verifying the verifiable presentation failed",
			"proofCreateFailed": "Creating the proof failed for method \"{verificationMethodId}\"",
			"proofVerifyFailed": "Verifying the proof failed"
		},
		"identityResolverService": {
			"noConnectors": "There are no connectors registered with the identity resolver factory",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the identity service \"{namespace}\"",
			"connectorNotFound": "There is no connector with the namespace \"{namespace}\" registered with the identity factory",
			"identityResolveFailed": "Resolving the identity failed \"{identity}\""
		},
		"identityProfileService": {
			"noConnectors": "There are no connectors registered with the identity profile factory",
			"alreadyExists": "The identity profile already exists for the identity \"{existingId}\"",
			"createFailed": "Creating the identity profile failed \"{identity}\"",
			"getFailed": "Getting the identity profile failed",
			"getPublicFailed": "Getting the public identity profile failed",
			"updateFailed": "Updating the identity profile failed \"{identity}\"",
			"notFound": "The identity profile could not be found \"{notFoundId}\"",
			"removeFailed": "Removing the identity profile failed \"{identity}\"",
			"listFailed": "Failed listing identities"
		},
		"immutableProofService": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the Immutable Proof service \"{namespace}\"",
			"createFailed": "Creating the proof failed",
			"getFailed": "Getting the proof failed",
			"verifyFailed": "Verifying the proof failed",
			"removeVerifiableFailed": "Removing verifiable entry from the Immutable Proof failed",
			"proofNotFound": "The proof with the Id \"{notFoundId}\" was not found"
		},
		"entityStorageVerifiableStorageConnector": {
			"verifiableStorageNotFound": "The verifiable item with the Id \"{notFoundId}\" was not found",
			"signatureFailed": "The signature verification failed",
			"creatingFailed": "Creating the item failed",
			"updatingFailed": "Updating the item failed",
			"gettingFailed": "Getting the item failed",
			"removingFailed": "Removing the item failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the IOTA Verifiable Storage connector \"{namespace}\"",
			"notInAllowList": "The user is not in the allow list",
			"notCreator": "Only the creator can remove the verifiable item",
			"allowListTooBig": "The number of items in the allow list is larger than the maximum allowed"
		},
		"iotaVerifiableStorageConnector": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the IOTA Verifiable Storage connector \"{namespace}\"",
			"creatingFailed": "Creating the verifiable item failed",
			"updatingFailed": "Updating the verifiable item failed",
			"gettingFailed": "Getting the verifiable item failed",
			"removingFailed": "Removing the verifiable item failed",
			"packageIdNotFound": "The package ID \"{id}\" was not found",
			"storingTransactionFailed": "The transaction to store the data failed",
			"removingTransactionFailed": "The transaction to remove the data failed",
			"objectNotFound": "The object was not found",
			"notAuthorized": "The controller address \"{controllerAddress}\" does not match the creator \"{creator}\" of the object",
			"invalidIdFormat": "The verifiable storage URN \"{id}\" has an invalid format",
			"connectorNotStarted": "Please call start() before using this connector. Package ID: \"{packageId}\" is missing.",
			"deployTransactionFailed": "Deploying the contract failed with error: \"{error}\"",
			"startFailed": "Failed to start the IOTA Verifiable Storage connector.",
			"invalidGasBudget": "The gas budget must be greater than 0",
			"notInAllowList": "The user is not in the allow list",
			"notCreator": "Only the creator can remove the verifiable item",
			"allowListTooBig": "The number of items in the allow list is larger than the maximum allowed"
		},
		"iotaVerifiableStorageUtils": {
			"invalidVerifiableStorageIdFormat": "The verifiable storage ID \"{id}\" has an invalid format"
		},
		"entityStorageNftConnector": {
			"nftNotFound": "The NFT with the ID \"{notFoundId}\" was not found",
			"notControllerTransfer": "The NFT can only be transferred by the controller",
			"notControllerBurn": "The NFT can only be burned by the controller",
			"notControllerUpdate": "The NFT can only be updated by the controller",
			"signatureFailed": "The signature verification failed",
			"mintingFailed": "Minting the NFT failed",
			"resolvingFailed": "Resolving the NFT failed",
			"burningFailed": "Burning the NFT failed",
			"transferFailed": "Transferring the NFT failed",
			"updatingFailed": "Updating the NFT failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the IOTA NFT connector \"{namespace}\""
		},
		"iotaNftConnector": {
			"mintingFailed": "Minting the NFT failed",
			"resolvingFailed": "Resolving the NFT failed",
			"burningFailed": "Burning the NFT failed",
			"transferFailed": "Transferring the NFT failed",
			"updateFailed": "Updating the NFT failed",
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the IOTA NFT connector \"{namespace}\"",
			"failedToGetNftId": "Failed to get NFT ID from mint response",
			"nftNotFound": "The NFT \"{nftId}\" was not found",
			"nftOwnerNftFound": "The owner for NFT \"{nftId}\" was not found",
			"startFailed": "Failed to start the IOTA NFT connector",
			"deployTransactionFailed": "Deploying the contract failed with error: \"{error}\"",
			"connectorNotStarted": "Please call start() before using this connector. Package ID: \"{packageId}\" is missing.",
			"invalidImmutableMetadata": "The immutable metadata for NFT \"{nftId}\" is invalid",
			"invalidMetadata": "The metadata for NFT \"{nftId}\" is invalid"
		},
		"iotaNftUtils": {
			"invalidNftIdFormat": "The NFT ID \"{id}\" has an invalid format"
		},
		"nftService": {
			"namespaceMismatch": "The namespace in the urn \"{id}\" does not match the namespace of the NFT service \"{namespace}\"",
			"noConnectors": "There are no connectors registered with the nft factory",
			"mintFailed": "The minting of the NFT failed",
			"resolveFailed": "The resolving of the NFT failed",
			"burnFailed": "The burning of the NFT failed",
			"transferFailed": "The transfer of the NFT failed",
			"updateFailed": "The update of the NFT failed"
		},
		"entityStorageTelemetryConnector": {
			"metricNotFound": "The metric could not be found \"{notFoundId}\"",
			"metricAlreadyExists": "The metric already exists \"{existingId}\"",
			"metricValueNotFound": "The metric value could not be found \"{notFoundId}\"",
			"counterIncOnly": "A counter metric can only be incremented, or added to with an integer",
			"upDownCounterIncOrDecOnly": "An up/down counter metric can only be incremented, decremented or adjusted with an integer",
			"gaugeNoIncDec": "A gauge can not be incremented or decremented"
		},
		"vaultConnectorHelper": {
			"invalidSignature": "The JSON Web token signature could not be verified"
		},
		"entityStorageVaultConnector": {
			"keyAlreadyExists": "The key \"{existingId}\" already exists in the vault",
			"keyNotFound": "The key \"{notFoundId}\" was not found in the vault",
			"secretNotFound": "The secret \"{notFoundId}\" was not found in the vault",
			"unsupportedKeyType": "The key type \"{keyType}\" is not supported",
			"keyTypeMismatch": "The key type \"{keyType}\" does not match the requested encryption method \"{encryptionType}\""
		},
		"hashicorpVaultConnector": {
			"setSecretFailed": "Failed to set secret \"{name}\"",
			"removeSecretFailed": "Failed to remove secret \"{name}\"",
			"getSecretVersionsFailed": "Failed to get secret versions \"{name}\"",
			"hashicorpVaultConnectionFailed": "Failed to connect to Hashicorp Vault",
			"createdKeyFailed": "Failed to create key \"{name, type}\"",
			"unsupportedKeyType": "Unsupported key type \"{type}\"",
			"exportPublicKeyFailed": "Failed to export public key \"{name}\"",
			"publicKeyNotFound": "Public key \"{name}\" not found",
			"removeKeyFailed": "Failed to remove key \"{name}\"",
			"updateKeyConfigFailed": "Failed to update key config \"{name}\"",
			"addKeyFailed": "Failed to add key \"{name, type}\"",
			"backupKeyNotFound": "Backup key \"{name}\" not found",
			"backupKeyFailed": "Failed to backup key \"{name}\"",
			"restoreKeyFailed": "Failed to restore key \"{name}\"",
			"exportKeyFailed": "Failed to export key \"{name}\" with keyPath \"{keyPath}\"",
			"exportKeyNotFound": "Export key with name \"{name}\" not found",
			"getKeyFailed": "Failed to get key \"{name}\"",
			"signDataFailed": "Failed to sign data \"{name}\"",
			"invalidSignResponse": "Invalid sign response \"{name}\"",
			"verifyDataFailed": "Failed to verify data \"{name}\"",
			"invalidSignature": "Invalid signature \"{name}\"",
			"encryptDataFailed": "Failed to encrypt data \"{name, encryptionType}\"",
			"unsupportedEncryptionType": "Unsupported encryption type \"{encryptionType}\"",
			"decryptDataFailed": "Failed to decrypt data \"{name, encryptionType}\"",
			"invalidEncryptResponse": "Invalid encrypt response \"{name, encryptionType}\"",
			"keyAlreadyExists": "Key \"{existingId}\" already exists",
			"invalidReadKeyResponse": "Invalid read key response \"{name}\"",
			"renameKeyFailed": "Failed to rename key from \"{name}\" to \"{newName}\"",
			"keyTypeMismatch": "The key type \"{keyType}\" does not match the requested encryption method \"{encryptionType}\""
		},
		"entityStorageWalletConnector": {
			"insufficientFunds": "There are insufficient funds in the wallet."
		},
		"iotaWalletConnector": {
			"transferFailed": "The wallet transfer failed."
		},
		"iotaFaucetConnector": {
			"fundingFailed": "Fund the address from faucet failed"
		},
		"rightsManagement": {
			"policyUidRequired": "Policy UID is required",
			"policyObjectRequired": "Policy Object is required"
		}
	},
	"errorNames": {
		"error": "Error",
		"generalError": "General",
		"guardError": "Guard",
		"conflictError": "Conflict",
		"notFoundError": "Not Found",
		"notSupportedError": "Not Supported",
		"alreadyExistsError": "Already Exists",
		"notImplementedError": "Not Implemented",
		"validationError": "Validation",
		"unprocessableError": "Unprocessable"
	},
	"validation": {
		"defaultFieldName": "The field"
	},
	"errorMessages": {
		"fetch": "Fetch"
	},
	"data-type-names": {
		"https://schema.org/Text": "Text",
		"https://schema.org/URL": "Url",
		"https://schema.org/Integer": "Integer",
		"https://schema.org/Float": "Float",
		"https://schema.org/Boolean": "Boolean",
		"https://schema.org/Date": "ISO Date",
		"https://schema.org/DateTime": "ISO Date Time",
		"https://schema.org/Time": "ISO Time",
		"https://schema.org/image": "Image",
		"https://schema.org/GeoCoordinates": "Geo Coordinates",
		"https://schema.org/StructuredValue": "Structured Value",
		"https://schema": {
			"org/Text": "Text",
			"org/URL": "Url",
			"org/Integer": "Integer",
			"org/Float": "Float",
			"org/Boolean": "Boolean",
			"org/Date": "ISO Date",
			"org/DateTime": "ISO Date Time",
			"org/Time": "ISO Time",
			"org/image": "Image",
			"org/GeoCoordinates": "Geo Coordinates",
			"org/StructuredValue": "Structured Value"
		}
	},
	"info": {
		"eventBusSocketClient": {
			"subscribe": "Subscription created for topic \"{topic}\" with id \"{subscriptionId}\"",
			"unsubscribe": "Subscription removed for topic \"{topic}\" with id \"{subscriptionId}\"",
			"publish": "Event publish for topic \"{topic}\" with id \"{eventId}\", with \"{subscriptionCount}\" subscriptions"
		},
		"s3BlobStorageConnector": {
			"bucketCreating": "Creating bucket \"{bucket}\"",
			"bucketCreated": "Created bucket \"{bucket}\"",
			"bucketExists": "Skipping create bucket \"{bucket}\" as it already exists"
		},
		"azureBlobStorageConnector": {
			"containerCreating": "Creating container \"{container}\"",
			"containerCreated": "Created container \"{container}\"",
			"containerExists": "Skipping create container \"{container}\" as it already exists"
		},
		"gcpBlobStorageConnector": {
			"bucketCreating": "Creating bucket \"{bucket}\"",
			"bucketCreated": "Created bucket \"{bucket}\"",
			"bucketExists": "Skipping create bucket \"{bucket}\" as it already exists"
		},
		"fileBlobStorageConnector": {
			"directoryCreating": "Creating directory \"{directory}\"",
			"directoryCreated": "Created directory \"{directory}\"",
			"directoryExists": "Skipping create directory \"{directory}\" as it already exists"
		},
		"dynamoDbEntityStorageConnector": {
			"tableCreating": "Creating table \"{tableName}\"",
			"tableCreated": "Created table \"{tableName}\"",
			"tableExists": "Skipping create table \"{tableName}\" as it already exists"
		},
		"fileEntityStorageConnector": {
			"directoryCreating": "Creating directory \"{directory}\"",
			"directoryCreated": "Created directory \"{directory}\"",
			"directoryExists": "Skipping create directory \"{directory}\" as it already exists"
		},
		"scyllaDBTableConnector": {
			"tableCreating": "Creating table \"{table}\"",
			"tableCreated": "Created table \"{table}\"",
			"tableExists": "Skipping create table \"{table}\" as it already exists",
			"typeCreated": "Created type \"{typeName}\"",
			"sql": "SQL: \"{sql}\""
		},
		"scyllaDBViewConnector": {
			"viewCreating": "Creating view \"{view}\"",
			"viewCreated": "Created view \"{view}\"",
			"viewExists": "Skipping create view \"{view}\" as it already exists",
			"typeCreated": "Created type \"{typeName}\"",
			"sql": "SQL: \"{sql}\""
		},
		"iotaVerifiableStorageConnector": {
			"contractAlreadyDeployed": "Contract already deployed",
			"contractDeploymentStarted": "Contract deployment started",
			"contractDeploymentCompleted": "Contract deployment completed"
		},
		"iotaNftConnector": {
			"contractAlreadyDeployed": "Contract already deployed",
			"contractDeploymentStarted": "Contract deployment started",
			"contractDeploymentCompleted": "Contract deployment completed"
		},
		"entityStorageTelemetryConnector": {
			"metricCreated": "The metric was created \"{id}\" with type \"type\" and label \"{label}\"",
			"metricUpdated": "The metric was updated \"{id}\" with type \"type\" and label \"{label}\"",
			"metricRemoved": "The metric was removed \"{id}\"",
			"metricValueCreated": "The metric value was created for \"{id}\" with value \"{value}\""
		},
		"hashicorpVaultConnector": {
			"hashicorpVaultConnected": "Connected to Hashicorp Vault"
		}
	},
	"verifiableCredentialStates": {
		"pendingVerification": "Pending Verification",
		"rejected": "Rejected",
		"issued": "Issued",
		"revoked": "Revoked"
	},
	"pages": {
		"error": {
			"title": "Error",
			"notFound": "The requested page could not be found"
		},
		"login": {
			"title": "Login",
			"email": "E-mail",
			"password": "Password",
			"signIn": "Sign in",
			"signingIn": "Signing in",
			"noAccount": "Don't have an account yet?",
			"signUp": "Sign up"
		},
		"identityProfile": {
			"title": "Profile",
			"qr": "Public Profile View",
			"identity": "Identity",
			"explore": "Explore",
			"firstName": "First Name",
			"lastName": "Last Name",
			"displayName": "Display Name",
			"displayNameDescription": "This will be the name that is displayed publicly when viewing your identity"
		},
		"identityPublic": {
			"title": "Identity Public Profile",
			"qr": "Public Profile View",
			"identity": "Identity",
			"schema": "Schema",
			"displayName": "Name",
			"explore": "Explore",
			"didDocument": "DID Document"
		},
		"attestation": {
			"title": "Attestations",
			"loading": "Loading attestations...",
			"noItems": "No attestations found",
			"createItem": "Create Attestation",
			"deleteTitle": "Delete Attestation",
			"currentHolder": "Current Owner",
			"deleteMessage": "Are you sure you want to delete this attestation?",
			"destroyTitle": "Destroy Attestation",
			"destroyMessage": "Are you sure you want to destroy this attestation? This action cannot be undone."
		},
		"attestationTransfer": {
			"title": "Transfer Attestation",
			"currentOwner": "Current Owner",
			"recipientIdentity": "New Recipient Identity",
			"recipientAddress": "New Recipient Address",
			"transfer": "Transfer",
			"transferSuccess": "Attestation transferred successfully",
			"progress": "Transferring attestation..."
		},
		"attestationProperties": {
			"title": "Create Attestation",
			"blob": "Blob",
			"selectBlob": "Select blob",
			"assertionMethod": "Assertion Method",
			"selectAssertionMethod": "Select assertion method",
			"attestationId": "Attestation Id",
			"attestationQr": "Attestation QR Code",
			"attestationOf": "Attestation of {blob}",
			"signature": "Signature",
			"action": "Attest",
			"actionSuccess": "Attestation was successful",
			"progress": "Attesting the document...",
			"resultTitle": "Attestation Result"
		},
		"nft": {
			"title": "Nfts",
			"loading": "Loading nfts...",
			"noItems": "No nfts found",
			"mintItem": "Mint Nft",
			"deleteTitle": "Delete Nft",
			"deleteMessage": "Are you sure you want to delete this nft?"
		},
		"nftProperties": {
			"title": "Mint Nft",
			"transferTitle": "Transfer Nft",
			"issuer": "Issuer",
			"tag": "Tag",
			"owner": "Owner",
			"name": "Name",
			"description": "Description",
			"uri": "Uri",
			"recipientIdentity": "New Recipient Identity",
			"recipientAddress": "New Recipient Address",
			"namespace": "Namespace (Optional)",
			"immutableMetadata": "Immutable Metadata (Optional)",
			"metadata": "Metadata (Optional)",
			"newMetadataKey": "New Metadata Key",
			"newMetadataValue": "New Metadata Value",
			"addMetadata": "Add Metadata",
			"selectBlob": "Select blob",
			"nftId": "Nft Id",
			"nftQr": "Nft QR Code",
			"nftOf": "Nft of {blob}",
			"signature": "Signature",
			"action": "Mint",
			"actionSuccess": "Minting was successful",
			"transfer": "Transfer",
			"transferSuccess": "Transferring was successful",
			"progress": "Action in progress...",
			"resultTitle": "Nft Result"
		},
		"immutableProof": {
			"title": "Immutable Proofs",
			"loading": "Loading immutable proofs...",
			"noItems": "No immutable proofs found",
			"createProof": "Create Proof",
			"deleteTitle": "Delete Proof",
			"deleteMessage": "Are you sure you want to delete this proof?"
		},
		"immutableProofProperties": {
			"title": "Create Immutable Proof",
			"proofObject": "Proof Object",
			"data": "Data",
			"addData": "Add Data",
			"proofId": "Proof Id",
			"action": "Create",
			"actionSuccess": "Proof creation was successful",
			"progress": "Creating proof...",
			"resultTitle": "Proof Result",
			"id": "Id",
			"userIdentity": "User Identity",
			"proofObjectId": "Proof Object Id",
			"dateCreated": "Date Created",
			"selectExample": "Select an example template"
		},
		"blob": {
			"title": "Blobs",
			"loading": "Loading blobs...",
			"noItems": "No blobs found",
			"createItem": "Create Blob",
			"deleteTitle": "Delete Blob",
			"deleteMessage": "Are you sure you want to delete this blob?"
		},
		"blobView": {
			"title": "Blob Storage",
			"id": "Id",
			"description": "Description",
			"fileExtension": "File Extension",
			"encodingFormat": "Encoding Format",
			"document": "Document",
			"download": "Download"
		},
		"blobProperties": {
			"title": "Create Blob",
			"description": "Description",
			"filename": "Filename",
			"action": "Upload",
			"actionSuccess": "Uploading was successful",
			"progress": "Uploading to storage...",
			"resultTitle": "Upload Result",
			"itemQr": "Blob Storage QR Code",
			"itemId": "Blob Id"
		},
		"verifiableStorage": {
			"title": "Verifiable Storage",
			"loading": "Loading verifiable storage...",
			"noItems": "No verifiable storage found",
			"createItem": "Create Verifiable Storage",
			"deleteTitle": "Delete Verifiable Storage",
			"deleteMessage": "Are you sure you want to delete this verifiable storage?",
			"qr": "Secure Storage View",
			"copyDataClipboard": "Copy data to clipboard"
		},
		"verifiableStorageView": {
			"title": "Verifiable Storage",
			"id": "Id",
			"description": "Description",
			"content": "Content",
			"download": "Download",
			"receipt": "Receipt",
			"explore": "Explore"
		},
		"verifiableStorageProperties": {
			"title": "Create Verifiable Storage",
			"description": "Description",
			"textContent": "Text Content",
			"progress": "Uploading to storage...",
			"action": "Upload",
			"actionSuccess": "Uploading was successful",
			"resultTitle": "Upload Result",
			"itemQr": "Verifiable Storage QR Code",
			"itemId": "Verifiable Storage Id",
			"data": "Data",
			"id": "Id"
		},
		"auditableItemGraphList": {
			"title": "Auditable Item Graphs",
			"loading": "Loading auditable item graphs vertices...",
			"noItems": "No auditable item graph vertices found",
			"createItem": "Create Auditable Item Vertex",
			"deleteTitle": "Delete Auditable Item Vertex",
			"deleteMessage": "Are you sure you want to delete this auditable item vertex?",
			"vertexId": "Vertex Id",
			"annotationObjectType": "Annotation Object Type"
		},
		"auditableItemGraphProperties": {
			"titleCreate": "Create Auditable Item Vertex",
			"titleUpdate": "Update Auditable Item Vertex",
			"description": "Description",
			"actionCreate": "Create",
			"actionCreateSuccess": "Creation was successful",
			"progressCreate": "Creating Vertex...",
			"progressUpdate": "Updating Vertex...",
			"resultTitleCreate": "Vertex created successfully",
			"resultTitleUpdate": "Vertex updated successfully",
			"itemQr": "Auditable Item Graph QR Code",
			"itemId": "Auditable Item Graph Id",
			"vertexId": "Vertex Id",
			"annotationObject": "Annotation Object",
			"selectExample": "Select an example template"
		},
		"auditableItemGraphAliasList": {
			"title": "Alias Ids",
			"noItems": "There are no aliases",
			"addItem": "Add Alias Id",
			"titleAdd": "Add Alias",
			"titleUpdate": "Update Alias",
			"aliasId": "Alias Id",
			"aliasFormat": "Format",
			"annotationObject": "Annotation Object",
			"selectExample": "Select an example template",
			"actionAdd": "Add",
			"actionUpdate": "Update"
		},
		"auditableItemGraphResourceList": {
			"title": "Resources",
			"noItems": "There are no resources",
			"addItem": "Add Resource",
			"titleAdd": "Add Resource",
			"titleUpdate": "Update Resource",
			"resourceId": "Resource Id",
			"resourceObject": "Resource Object",
			"selectExample": "Select an example template",
			"actionAdd": "Add",
			"actionUpdate": "Update"
		},
		"auditableItemGraphEdgeList": {
			"title": "Edges",
			"noItems": "There are no edges",
			"addItem": "Add Edge",
			"titleAdd": "Add Edge",
			"titleUpdate": "Update Edge",
			"edgeId": "Edge Id",
			"edgeRelationships": "Edge Relationships",
			"edgeRelationshipsHelp": "Separate multiple relationships with commas",
			"annotationObject": "Annotation Object",
			"selectExample": "Select an example template",
			"actionAdd": "Add",
			"actionUpdate": "Update"
		},
		"auditableItemGraphChangesets": {
			"title": "Changesets",
			"vertexId": "Vertex Id",
			"noItems": "There are no changesets",
			"changeset": "Changeset",
			"proofId": "Proof Id",
			"viewProof": "View Proof",
			"patches": "Patches",
			"dateCreated": "Date Created"
		},
		"auditableItemStream": {
			"title": "Auditable Item Streams",
			"loading": "Loading auditable item streams...",
			"noItems": "No auditable item streams found",
			"createItem": "Create Auditable Item Stream",
			"deleteTitle": "Delete Auditable Item Stream",
			"deleteMessage": "Are you sure you want to delete this auditable item stream?",
			"id": "Id"
		},
		"auditableItemStreamProperties": {
			"titleCreate": "Create Auditable Item Stream",
			"titleUpdate": "Update Auditable Item Stream",
			"name": "Name",
			"template": "Template",
			"annotationObject": "Annotation Object",
			"immutableInterval": "Immutable Interval",
			"actionCreate": "Create",
			"actionSuccessCreate": "Creation was successful",
			"progressCreate": "Creating...",
			"resultTitleCreate": "Create Result",
			"actionUpdate": "Update",
			"actionSuccessUpdate": "Updating was successful",
			"progressUpdate": "Updating...",
			"resultTitleUpdate": "Update Result",
			"itemQr": "Auditable Item Stream QR Code",
			"itemId": "Auditable Item Stream Id"
		},
		"auditableItemStreamEntriesList": {
			"title": "Stream Entries",
			"addEntry": "Add Entry",
			"entryId": "Entry Id",
			"entryType": "Entry Type",
			"details": "Details",
			"noEntries": "There are no entries in the stream",
			"deleteTitle": "Delete Stream Entry",
			"deleteMessage": "Are you sure you want to delete this stream entry?"
		},
		"auditableItemStreamEntryProperties": {
			"titleCreate": "Create Stream Entry",
			"titleUpdate": "Update Stream Entry",
			"actionCreate": "Create",
			"actionUpdate": "Update",
			"progressUpdate": "Updating...",
			"progressCreate": "Creating...",
			"entryId": "Entry Id",
			"entryObject": "Entry Object",
			"template": "Template"
		},
		"logging": {
			"title": "Logging",
			"search": "Search",
			"loading": "Loading logs...",
			"noItems": "No logs found",
			"action": "Filter",
			"actions": "Actions",
			"progress": "Searching...",
			"copyAllClipboard": "Copy all log to clipboard",
			"copyDataClipboard": "Copy the data body to clipboard",
			"copyErrorClipboard": "Copy the error to clipboard"
		},
		"loggingProperties": {
			"title": "Logging",
			"level": "Level",
			"source": "Source",
			"message": "Message",
			"error": "Error",
			"ts": "Timestamp",
			"data": "Data",
			"pageSize": "Page Size",
			"timeStart": "From Date",
			"timeEnd": "To Date"
		},
		"telemetry": {
			"title": "Telemetry",
			"search": "Search",
			"createMetric": "Create Metric",
			"loading": "Loading metrics...",
			"noItems": "No metrics found",
			"action": "Create",
			"actions": "Actions",
			"progress": "Searching...",
			"deleteTitle": "Delete Telemetry Metric",
			"deleteMessage": "Are you sure you want to delete this metric?",
			"pageSize": "Page Size",
			"timeStart": "From Date",
			"id": "Id",
			"label": "Label",
			"description": "Description",
			"type": "Type",
			"unit": "Unit"
		},
		"telemetryMetricProperties": {
			"title": "Telemetry Metric",
			"id": "Id",
			"label": "Label",
			"description": "Description",
			"type": "Type",
			"unit": "Unit",
			"message": "Message",
			"error": "Error",
			"actionSuccessCreated": "Metric created successfully",
			"actionSuccessUpdated": "Metric updated successfully",
			"resultTitleCreate": "Create Metric Result",
			"resultTitleUpdate": "Update Metric Result",
			"timeEnd": "To Date",
			"metricTypes": {
				"counter": "Counter",
				"gauge": "Gauge",
				"incDecCounter": "Increment Decrement Counter"
			}
		},
		"telemetryMetricValueProperties": {
			"title": "Telemetry Metric Value",
			"incDecSelector": "Increment/Decrement",
			"action": "Add",
			"increment": "Increment",
			"decrement": "Decrement",
			"customDataKey": "New Key",
			"customDataValue": "New Value",
			"customValues": "Custom Data",
			"addCustomData": "Add custom data",
			"value": "Value",
			"valueExample": "e.g. 1.23",
			"progress": "Adding..."
		},
		"telemetryMetricValueList": {
			"title": "Telemetry Metric Values",
			"pageSize": "Page Size",
			"timeStart": "From Date",
			"timeEnd": "To Date",
			"createMetricValue": "Create Metric Value",
			"noItems": "No metric values found",
			"value": "Value",
			"id": "Id",
			"timestamp": "Timestamp",
			"customData": "Custom Data",
			"graph": "View Graph"
		},
		"telemetryMetricValueChart": {
			"title": "Telemetry Metric Chart",
			"loading": "Loading chart data..."
		},
		"proofView": {
			"title": "Proof View",
			"type": "Type",
			"header": "Header",
			"payload": "Payload",
			"signature": "Signature"
		},
		"dataProcessingRuleGroupList": {
			"title": "Data Processing",
			"search": "Search",
			"createRuleGroup": "Create Rule Group",
			"extractData": "Extract Data",
			"loading": "Loading rule groups...",
			"noItems": "No rule groups found",
			"action": "Create",
			"actions": "Actions",
			"progress": "Searching...",
			"deleteTitle": "Delete Rule Group",
			"deleteMessage": "Are you sure you want to delete this rule group?",
			"error": "Error",
			"pageSize": "Page Size",
			"id": "Id",
			"label": "Label"
		},
		"dataProcessingRuleGroupProperties": {
			"title": "Data Processing Rule Group",
			"id": "Id",
			"label": "Label",
			"message": "Message",
			"error": "Error",
			"pageSize": "Page Size",
			"actionCreate": "Create",
			"actionUpdate": "Update",
			"actionSuccess": "Rule group added correctly",
			"resultTitleCreate": "Created Rule Group",
			"resultTitleUpdate": "Updated Rule Group",
			"progressCreate": "Creating...",
			"progressUpdate": "Updating..."
		},
		"dataProcessingRuleGroupRuleList": {
			"title": "Data Processing Rule Group",
			"loading": "Loading Rules...",
			"createRule": "Create Rule",
			"noItems": "No rules found",
			"source": "Source",
			"target": "Target",
			"actions": "Actions",
			"deleteTitle": "Delete Rule",
			"deleteMessage": "Are you sure you want to delete this rule?"
		},
		"dataProcessingRuleGroupRuleProperties": {
			"title": "Data Processing Rule Group Rule",
			"error": "Error",
			"target": "Target",
			"rule": "Rule",
			"rules": "Rules",
			"source": "Source",
			"sourceDescription": "The format of the source follows the JSONPath standard. e.g. $.store.book[0].title",
			"moreInformation": "More information",
			"retainPathDepth": "Retain Path Depth",
			"coerce": "Coerce Type",
			"coerceNone": "None",
			"actionCreate": "Create",
			"actionUpdate": "Update",
			"progressCreate": "Creating...",
			"progressUpdate": "Updating..."
		},
		"dataProcessingExtractView": {
			"title": "Data Processing Extract",
			"action": "Extract",
			"actionSuccess": "Data extraction completed",
			"error": "Error",
			"progress": "Extracting...",
			"fileInput": "File Input",
			"fileOutput": "File Output",
			"ruleGroup": "Rule Group",
			"rules": "Rules",
			"inputContent": "Input Content",
			"extractedData": "Extracted Data"
		},
		"documentView": {
			"title": "Document View",
			"id": "Document ID",
			"documentIdFormat": "Document ID Format",
			"documentCode": "Document Code",
			"fileExtension": "File Extension",
			"encodingFormat": "Encoding Format",
			"document": "Document",
			"qr": "QR Code",
			"selectFile": "Select a file",
			"update": "Update",
			"annotationObject": "Annotation Object",
			"updating": "Updating Document...",
			"deleteTitle": "Delete Document Revision",
			"deleteMessage": "Are you sure you want to delete this document revision?",
			"deleteSuccess": "Document revision deleted successfully",
			"documentView": "Document Revision Count",
			"invalidJson": "Invalid JSON format",
			"noDocumentsFound": "No documents found for this revision",
			"documentRevision": "Document Revision",
			"revisionHistory": "Revision History",
			"documentDetails": "Document Details",
			"documentId": "Document Id",
			"hideDeletedDocuments": "Hide deleted documents",
			"showDeletedDocuments": "Show deleted documents",
			"dateDeleted": "Date Deleted",
			"fileContent": "File Content"
		},
		"document": {
			"title": "Documents",
			"loading": "Loading documents...",
			"noItems": "No documents found",
			"createItem": "Create Document",
			"deleteTitle": "Delete Document",
			"deleteMessage": "Are you sure you want to delete this document?",
			"documentId": "Document ID",
			"graphId": "Graph ID",
			"searchById": "Search by Graph ID",
			"searchPlaceholder": "Enter Graph ID",
			"noSearchResults": "No documents found"
		},
		"documentProperties": {
			"title": "Create Document",
			"updateTitle": "Update Document",
			"documentId": "Document Id",
			"documentName": "Document Name",
			"documentIdFormat": "Document Id Format",
			"documentCode": "Document Code",
			"file": "File",
			"action": "Create",
			"actionUpdate": "Update",
			"actionSuccess": "Create was successful",
			"updateSuccess": "Update was successful",
			"invalidJson": "Invalid JSON format",
			"progress": "Creating...",
			"updateProgress": "Updating...",
			"resultTitle": "Create Result",
			"itemQr": "Document Storage QR Code",
			"itemId": "Document Id",
			"auditableItemGraphId": "Graph ID",
			"fileUpdateOptional": "Selecting a file is optional for updates",
			"advancedOptions": "Advanced Options",
			"annotationObject": "Annotation Object (JSON)",
			"auditableItemGraphEdges": "Auditable Item Graph Edges",
			"documentOptions": "Document Options",
			"createAttestation": "Create Attestation",
			"addAlias": "Add Alias",
			"aliasAnnotationObject": "Alias Annotation Object (JSON)",
			"vertexId": "Vertex ID",
			"vertexAddAlias": "Add Alias on Destination Vertex",
			"edgeAliasAnnotationObject": "Edge Alias Annotation Object (JSON)",
			"selectEdge": "Select Edge",
			"noEdgesAvailable": "No edges available",
			"createVertexFirst": "There are no vertices to connect to, create another vertex first.",
			"createVertexLink": "Create Vertex",
			"selectGraph": "Select Graph"
		},
		"documentExtract": {
			"title": "Document Extraction",
			"id": "Document Id",
			"chooseRule": "Choose Extraction Data Rule",
			"selectOption": "Select an option",
			"extractData": "Extract Data",
			"dataExtracted": "Data extracted from file",
			"fileContent": "File Content"
		},
		"rightsManagement": {
			"title": "Rights Management Policies",
			"loading": "Loading Policies...",
			"noItems": "No Policies found",
			"createPolicy": "Create Policy",
			"deleteTitle": "Delete Policy",
			"deleteMessage": "Are you sure you want to delete this policy?",
			"pageSize": "Page Size",
			"policyType": "Policy Type",
			"search": "Search"
		},
		"rightsManagementProperties": {
			"title": "Create Policy",
			"titleUpdate": "Update Policy",
			"policyObject": "Policy Object",
			"data": "Data",
			"addData": "Add Data",
			"policyId": "Policy Id",
			"action": "Create",
			"actionSuccess": "Policy creation was successful",
			"actionSuccessUpdate": "Policy update was successful",
			"progress": "Creating policy...",
			"progressUpdate": "Updating policy...",
			"resultTitle": "Policy Result",
			"resultTitleUpdate": "Policy Update Result",
			"id": "Id",
			"context": "Context",
			"type": "Type",
			"userIdentity": "User Identity",
			"policyObjectId": "Policy Object Id",
			"selectExample": "Select an example template",
			"uidMessage": "Policy UID is self regenerated and cannot be modified"
		}
	},
	"actions": {
		"save": "Save",
		"saveSuccess": "Saved successfully",
		"open": "Open",
		"close": "Close",
		"back": "Back",
		"yes": "Yes",
		"no": "No",
		"ok": "OK",
		"cancel": "Cancel",
		"modify": "Modify",
		"delete": "Delete",
		"view": "View More",
		"decode": "Decode",
		"add": "Add",
		"create": "Create",
		"update": "Update"
	},
	"components": {
		"serverStatus": {
			"api": "API",
			"notConnected": "Not connected"
		},
		"appFooter": {
			"language": "Language",
			"colorTheme": "Color theme",
			"selectLanguage": "Select language"
		},
		"blobViewer": {
			"noBlobData": "No blob data available",
			"unsupportedFormatInline": "This content format cannot be displayed inline",
			"invalidTextContent": "Unable to decode text content",
			"pdfContent": "PDF content"
		},
		"attestationView": {
			"title": "Attestation",
			"id": "Id",
			"exploreNft": "Explore NFT",
			"attestationQr": "Attestation QR Code",
			"verified": "Verified",
			"created": "Created",
			"ownerIdentity": "Owner Identity",
			"transferred": "Transferred",
			"holderIdentity": "Holder Identity",
			"attestationObject": "Attestation Object",
			"proof": "Proof"
		},
		"nftView": {
			"title": "Nft",
			"id": "Id",
			"exploreNft": "Explore NFT",
			"nftQr": "Nft QR Code",
			"verified": "Verified",
			"created": "Created",
			"issuer": "Issuer",
			"tag": "Tag",
			"owner": "Owner",
			"name": "Name",
			"description": "Description",
			"uri": "Uri",
			"immutableMetadata": "Immutable Metadata",
			"metadata": "Metadata",
			"transferred": "Transferred",
			"holderIdentity": "Holder Identity",
			"nftObject": "Nft Object",
			"proof": "Proof"
		},
		"loggingView": {
			"title": "Logging"
		},
		"auditableItemStreamView": {
			"title": "Auditable Item Stream",
			"id": "Id",
			"auditableItemStreamQr": "Auditable Item Stream QR Code",
			"viewProof": "View Proof",
			"proofId": "Proof Id",
			"entries": "Entries",
			"entryId": "Entry Id"
		},
		"immutableProofView": {
			"title": "Immutable Proof",
			"id": "Id",
			"proof": "Proof",
			"receipt": "Receipt",
			"verified": "Verified",
			"failure": "Failure message",
			"explorer": "Explorer"
		},
		"immutableProofReceipt": {
			"title": "Verifiable Receipt",
			"type": "Type",
			"id": "Id",
			"transactionId": "Transaction Id",
			"network": "Network",
			"epoch": "Epoch",
			"digest": "Digest",
			"entityStorageId": "Entity Storage Id",
			"explore": "Explore"
		},
		"rightsManagementView": {
			"title": "Rights Management Policy",
			"id": "Id",
			"policy": "Policy",
			"receipt": "Receipt",
			"verified": "Verified",
			"failure": "Failure message",
			"explorer": "Explorer"
		}
	},
	"nftAttestationConnector": {
		"verificationFailures": {
			"noData": "There is no data in the resolved NFT",
			"proofFailed": "The proof of the attestation could not be verified",
			"revoked": "The proof of the attestation has been revoked"
		}
	},
	"fastifyWebServer": {
		"building": "Building Web Server",
		"starting": "Starting Web Server at address \"{host}\" on port \"{port}\"",
		"startFailed": "The Web Server failed to start",
		"started": "The Web Server started on {addresses}",
		"stopped": "The Web Server was stopped",
		"badRequest": "The web server could not handle the request",
		"restRouteAdded": "Added REST route \"{route}\" \"{method}\"",
		"socketRouteAdded": "Added socket route \"{route}\"",
		"noRestProcessors": "You must configure at least one REST processor",
		"noSocketProcessors": "You must configure at least one socket processor",
		"postProcessorError": "There was a failure after in a post processor for route \"{route}\""
	},
	"auditableItemGraphService": {},
	"cli": {
		"progress": {
			"done": "Done.",
			"error": "Error",
			"loadingEnvFiles": "Loading env files",
			"pleaseWait": "Please wait...",
			"writingJsonFile": "Writing JSON file",
			"writingEnvFile": "Writing env file",
			"readingJsonFile": "Reading JSON file",
			"readingEnvFile": "Reading env file"
		},
		"options": {
			"lang": {
				"param": "--lang '<'lang'>'",
				"description": "The language to display the output in."
			},
			"load-env": {
				"param": "--load-env [env...]",
				"description": "Load the env files to initialise any environment variables."
			},
			"no-console": {
				"param": "--no-console",
				"description": "Hides the output in the console."
			},
			"json": {
				"param": "--json '<'filename'>'",
				"description": "Creates a JSON file containing the output."
			},
			"env": {
				"param": "--env '<'filename'>'",
				"description": "Creates an env file containing the output."
			},
			"merge-json": {
				"param": "--merge-json",
				"description": "If the JSON file already exists merge the data instead of overwriting."
			},
			"merge-env": {
				"param": "--merge-env",
				"description": "If the env file already exists merge the data instead of overwriting."
			}
		}
	},
	"app": {
		"name": "Playground"
	},
	"navigation": {
		"login": "Login",
		"logout": "Logout",
		"dashboard": "Dashboard",
		"telemetry": "Telemetry",
		"logging": "Logging",
		"blobs": "Blobs",
		"documents": "Documents",
		"attestations": "Attestations",
		"auditable-item-graphs": "Auditable Item Graphs",
		"auditable-item-streams": "Auditable Item Streams",
		"nft": "NFT",
		"verifiable-storage": "Verifiable Storage",
		"immutable-proof": "Immutable Proof",
		"data-processing": "Data Processing",
		"rights-management": "Rights Management"
	},
	"common": {
		"labels": {
			"description": "Description",
			"dateCreated": "Date Created",
			"dateModified": "Date Modified",
			"actions": "Actions",
			"search": "Search",
			"clear": "Clear",
			"dateDeleted": "Date Deleted"
		}
	}
}
